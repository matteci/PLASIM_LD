import sys
from shutil import copy
import numpy as np
import math
from netCDF4 import Dataset

# read input
script=sys.argv[0]
expdir=sys.argv[1]
expname=sys.argv[2]
ntrajs=int(sys.argv[3])
block=int(sys.argv[4])
varname=sys.argv[5]
k=float(sys.argv[6])
dt=float(sys.argv[7])
maskname=sys.argv[8]
gpareaname=sys.argv[9]

# define folders as in main script (many are not actually needed)
runexpdir=expdir+'/run'
dataexpdir=expdir+'/data'
restexpdir=expdir+'/rest'
initexpdir=expdir+'/init'
diagexpdir=expdir+'/diag'
postexpdir=expdir+'/post'
resamplingexpdir=expdir+'/resampling'
scriptsexpdir=expdir+'/scripts'
modelexpdir=expdir+'/model'
burnerexpdir=expdir+'/burner'

# # load mask and gridpoints area
# dataset=Dataset(postexpdir+'/utils/'+maskname)
# lon=dataset.variables['lon'][:]
# lat=dataset.variables['lat'][:]
# LON,LAT=np.meshgrid(lon,lat)
# mask=dataset.variables['lsm'][:]
# mask=np.mean(mask,axis=0)
# dataset=Dataset(postexpdir+'/utils/'+gpareaname)
# gparea=dataset.variables['cell_area'][:]

# mask_world=np.zeros(mask.shape)
# mask_world[mask>0]=1


# ### definisce mask NH ###
# mask_NH=np.zeros(mask.shape)
# mask_NH[mask<1]=1
# mask_NH[LAT<0]=0
# mask=mask_NH*gparea 
# areamask=np.sum(mask,axis=(0,1)) 


# # compute the weights associated to each trajectory
# traj=0
# datafilename=expname+'_ctrlobs.'+str(traj+1).zfill(4)+'.'+str(block).zfill(4)+'.nc'
# dataset=Dataset(postexpdir+'/ctrlobs/'+datafilename)
# obs=dataset.variables[varname][:]
# obsts=np.empty((ntrajs,obs.shape[0])) 
# obsmean=np.empty(ntrajs)
# for traj in range(ntrajs):
#     datafilename=expname+'_ctrlobs.'+str(traj+1).zfill(4)+'.'+str(block).zfill(4)+'.nc'
#     dataset=Dataset(postexpdir+'/ctrlobs/'+datafilename)
#     obs=dataset.variables[varname][:]
#     for t in range(obsts.shape[1]):
#         obsts[traj,t]=np.sum(np.squeeze(obs[t,:,:])*mask,axis=(0,1))
#     obsmean[traj]=np.sum(obsts[traj,:])*dt # vettore che per ogni traiettoria ha integrale osservabile
        
# if varname == 'icec' or varname == 'icev':
#     obsmean=obsmean/(10**12)

##
obsmean=np.empty(ntrajs)
traj=0
for traj in range(ntrajs):
    datafilename=expname+'_ctrlobs.'+str(traj+1).zfill(4)+'.'+str(block).zfill(4)+'.txt'
    dataset=postexpdir+'/ctrlobs/'+datafilename
    with open(dataset) as f:
        obsmean[traj] = f.readline()
        print(obsmean[traj])


### ORA FAI IL RESAMPLING
#W=np.exp(k*(obsmean-np.mean(obsmean))) # TOGLIE MEDIA PER QUESTIONE NUMERICA, EVITARE ESPONENZIALI ALTI
W=np.exp(k*(-obsmean+np.mean(obsmean))) # LOOK FOR MINIMUM

# compute the normalizer and the normalized weights
R=sum(W)/ntrajs
w=W/R # CALCOLA IL PESO

# compute the number of clones generated by trajectory
nc=np.empty(ntrajs)
for traj in range(ntrajs):
    nc[traj]=math.floor(w[traj]+np.random.uniform(0,1)) #CALCOLA NUMERO DI CLONI GENERATI DA CIASCUNA TRAIETTORIA

## RITOCCHI NUMERO CLONI PER MANTNERE ENSEMBLE SIZE COSTANTE
# compute total number of clones and difference with original ensemble size
Nc=sum(nc)
dN=Nc-ntrajs

#print(Nc)
#print(dN)

# if the clones are less than what is needed, clone randomly among the succesfull 
# trajectories (proportionally to the number of clones they are originally meant 
# to produce), with repetition
label=np.arange(ntrajs)
#print(label)
if dN<0:
    traj2clone=np.empty(int(-dN))
    for traj in range(int(-dN)):    
        traj2clone[traj]=np.random.choice(label,p=nc/sum(nc))  
        #print(traj)
        #print(traj2clone[traj])
    for traj in range(int(-dN)):
        nc[int(traj2clone[traj])]=nc[int(traj2clone[traj])]+1
# if the clones are more than what is needed, kill randomly among the succesfull 
# trajectories (proportionally to the number of clones they are originally meant 
# to produce), without repetition
if dN>0:
    traj2kill=np.empty(int(dN))
    for traj in range(int(dN)):
        traj2kill[traj]=np.random.choice(label,p=nc/sum(nc))
        #print(traj)
        #print(traj2kill[traj])
        nc[int(traj2kill[traj])]=nc[int(traj2kill[traj])]-1
# note on the procedure above: the random selection is performed proportionally 
# to the number of clones the trajectories are originally meant to produce. This 
# means selecting on the population of trajectories present after the resampling: 
# what is done above is a correction to the resampling

# define a label array with 0 if the trajectory survives, 1 if it is killed and 
# it is meant to be substituted by a copy of a succesfull trajectory
killedlabel=np.empty(ntrajs)
for traj in range(ntrajs):
    if nc[traj]>0:
        killedlabel[traj]=0
    else:
        killedlabel[traj]=1

print(nc)
        
# for each trajectory, determine the label of the trajectory whose restart will 
# be used to continue the evolution. Originally this initialization label is equal 
# to the label of the trajectory itself: the trajectory continues its own evolution.
# If nc is 0 (the trajectory will be killed) or 1 (the trajectory continues its own
# evolution but is not cloned) nothing is done. If nc>1 (the trajectory spawns nc-1
# clones, in addition to continuing its own evolution), pick randomly nc-1 trajectories 
# among those meant to be killed, and give them the label of the spawning trajectory.
# The label array of the trajectories to be killed is updated every time, in order to
# be sure to substitute all the killed trajectories by the end of the loop.     

# PASSI ALLE TRAIETTORIE UCCISE I CLONI DELLE TRAIETTORIE DI SUCCESSO
initlabel=np.arange(ntrajs)
udkilledlabel=np.empty(ntrajs)
udkilledlabel[:]=killedlabel[:]
for traj in range(ntrajs):
    if nc[traj]>1:
        for n in range(int(nc[traj])-1):
            traj2substitute=np.random.choice(label,p=udkilledlabel/sum(udkilledlabel))
            initlabel[int(traj2substitute)]=traj
            udkilledlabel[int(traj2substitute)]=0

#print(killedlabel)
#print(udkilledlabel)
#print(initlabel)

# write the init files accordingly to the cloning, and copy them into the run folders
for traj in range(ntrajs):
    initfilename=expname+'_init.'+str(traj+1).zfill(4)+'.'+str(block+1).zfill(4)
    restfilename=expname+'_rest.'+str(initlabel[traj]+1).zfill(4)+'.'+str(block).zfill(4)
    copy(restexpdir+'/block_'+str(block).zfill(4)+'/'+restfilename,initexpdir+'/block_'+str(block+1).zfill(4)+'/'+initfilename)

    lsginitfilename=expname+'_lsginit.'+str(traj+1).zfill(4)+'.'+str(block+1).zfill(4)
    lsgrestfilename=expname+'_lsgrest.'+str(initlabel[traj]+1).zfill(4)+'.'+str(block).zfill(4)
    copy(restexpdir+'/block_'+str(block).zfill(4)+'/'+lsgrestfilename,initexpdir+'/block_'+str(block+1).zfill(4)+'/'+lsginitfilename)

    copy(restexpdir+'/block_'+str(block).zfill(4)+'/kleiswi',initexpdir+'/block_'+str(block+1).zfill(4)+'/kleiswi')
    copy(restexpdir+'/block_'+str(block).zfill(4)+'/mat77',initexpdir+'/block_'+str(block+1).zfill(4)+'/mat77')
# save all the relevant informations about the resampling                        
#np.savez(resamplingexpdir+'/block_'+str(block).zfill(4)+'/'+expname+'_resampling.'+str(block).zfill(4),\
#         ntrajs=ntrajs,Nc=Nc,dN=dN,R=R,W=W,w=w,nc=nc,killedlabel=killedlabel,udkilledlabel=udkilledlabel,initlabel=initlabel,k=k,dt=dt,\
#         obsts=obsts,obsmean=obsmean,LAT=LAT,LON=LON,mask_world=mask_world,mask_NH=mask_NH,gparea=gparea)
np.savez(resamplingexpdir+'/block_'+str(block).zfill(4)+'/'+expname+'_resampling.'+str(block).zfill(4),\
         ntrajs=ntrajs,Nc=Nc,dN=dN,R=R,W=W,w=w,nc=nc,killedlabel=killedlabel,udkilledlabel=udkilledlabel,initlabel=initlabel,k=k,dt=dt,\
         obsmean=obsmean)

### note ###
### Traiettorie vanno ricostruite dalla fine guardando gli init labels: esiste una funzione la vediamo la prossima volta
############

